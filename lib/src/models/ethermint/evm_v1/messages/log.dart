import 'package:blockchain_utils/helper/helper.dart';
import 'package:blockchain_utils/utils/utils.dart';
import 'package:cosmos_sdk/src/models/ethermint/evm_v1/types/types.dart';
import 'package:cosmos_sdk/src/protobuf/protobuf.dart';
import 'package:cosmos_sdk/src/utils/utils.dart';

/// Log represents an protobuf compatible Ethereum Log that defines a contract
/// log event. These events are generated by the LOG opcode and stored/indexed by
/// the node.
//
/// NOTE: address, topics and data are consensus fields. The rest of the fields
/// are derived, i.e. filled in by the nodes, but not secured by consensus.
class EVMV1Log extends CosmosMessage {
  /// address of the contract that generated the event
  final String address;

  /// topics is a list of topics provided by the contract.
  final List<String> topics;

  /// data which is supplied by the contract, usually ABI-encoded
  final List<int> data;

  /// block_number of the block in which the transaction was included
  final BigInt blockNumber;

  /// tx_hash is the transaction hash
  final String transactionHash;

  /// tx_index of the transaction in the block
  final BigInt transactionIndex;

  /// block_hash of the block in which the transaction was included
  final String blockHash;

  /// index of the log in the block
  final BigInt logIndex;

  /// removed is true if this log was reverted due to a chain
  /// reorganisation. You must pay attention to this field if you receive logs
  /// through a filter query.
  final bool removed;
  EVMV1Log(
      {required this.address,
      required List<String> topics,
      required List<int> data,
      required this.blockNumber,
      required this.transactionHash,
      required this.transactionIndex,
      required this.blockHash,
      required this.logIndex,
      required this.removed})
      : data = data.immutable,
        topics = topics.immutable;
  factory EVMV1Log.fromRpc(Map<String, dynamic> json) {
    return EVMV1Log(
        address: json["address"],
        blockHash: json["block_hash"],
        blockNumber: BigintUtils.parse(json["block_number"]),
        data: CosmosUtils.toBytes(json["data"]),
        logIndex: BigintUtils.parse(json["index"]),
        removed: json["removed"],
        topics: (json["topics"] as List?)?.cast() ?? [],
        transactionHash: json["tx_hash"],
        transactionIndex: BigintUtils.parse(json["tx_index"]));
  }
  factory EVMV1Log.deserialize(List<int> bytes) {
    final decode = CosmosProtocolBuffer.decode(bytes);
    return EVMV1Log(
        address: decode.getField(1),
        topics: decode.getFields<String>(2),
        data: decode.getField(3),
        blockNumber: decode.getField(4),
        transactionHash: decode.getField(5),
        transactionIndex: decode.getField(6),
        blockHash: decode.getField(7),
        logIndex: decode.getField(8),
        removed: decode.getField(9));
  }

  @override
  List<int> get fieldIds => [1, 2, 3, 4, 5, 6, 7, 8, 9];

  @override
  Map<String, dynamic> toJson() {
    return {
      "address": address,
      "topics": topics,
      "data": BytesUtils.toHexString(data),
      "block_number": blockNumber,
      "tx_hash": transactionHash,
      "tx_index": transactionIndex,
      "block_hash": blockHash,
      "index": logIndex,
      "removed": removed
    };
  }

  @override
  TypeUrl get typeUrl => EvmV1Types.log;

  @override
  List get values => [
        address,
        topics,
        data,
        blockNumber,
        transactionHash,
        transactionIndex,
        blockHash,
        logIndex,
        removed
      ];
}
