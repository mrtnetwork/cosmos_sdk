import 'package:blockchain_utils/helper/helper.dart';
import 'package:blockchain_utils/utils/utils.dart';
import 'package:cosmos_sdk/src/models/evmos/types/types.dart';
import 'package:cosmos_sdk/src/protobuf/protobuf.dart';
import 'package:cosmos_sdk/src/utils/utils.dart';

/// Log represents an protobuf compatible Ethereum Log that defines a contract
/// log event. These events are generated by the LOG opcode and stored/indexed by
/// the node.
//
/// NOTE: address, topics and data are consensus fields. The rest of the fields
/// are derived, i.e. filled in by the nodes, but not secured by consensus.
class EvmosEthermintEVMV1Log extends CosmosMessage {
  /// address of the contract that generated the event
  final String address;

  /// topics is a list of topics provided by the contract.
  final List<String> topics;

  /// data which is supplied by the contract, usually ABI-encoded
  final List<int> data;

  /// block_number of the block in which the transaction was included
  final BigInt blockNumber;

  /// tx_hash is the transaction hash
  final String transactionHash;

  /// tx_index of the transaction in the block
  final BigInt transactionIndex;

  /// block_hash of the block in which the transaction was included
  final String blockHash;

  /// index of the log in the block
  final BigInt logIndex;

  /// removed is true if this log was reverted due to a chain
  /// reorganisation. You must pay attention to this field if you receive logs
  /// through a filter query.
  final bool removed;
  EvmosEthermintEVMV1Log({
    required this.address,
    required List<String> topics,
    required List<int> data,
    required this.blockNumber,
    required this.transactionHash,
    required this.transactionIndex,
    required this.blockHash,
    required this.logIndex,
    required this.removed,
  }) : data = data.immutable,
       topics = topics.immutable;
  factory EvmosEthermintEVMV1Log.fromJson(Map<String, dynamic> json) {
    return EvmosEthermintEVMV1Log(
      address: json["address"],
      blockHash: json["block_hash"],
      blockNumber: BigintUtils.parse(json["block_number"]),
      data: CosmosUtils.toBytes(json["data"]),
      logIndex: BigintUtils.parse(json["index"]),
      removed: json["removed"],
      topics: (json["topics"] as List?)?.cast() ?? [],
      transactionHash: json["tx_hash"],
      transactionIndex: BigintUtils.parse(json["tx_index"]),
    );
  }
  factory EvmosEthermintEVMV1Log.deserialize(List<int> bytes) {
    final decode = CosmosProtocolBuffer.decode(bytes);
    return EvmosEthermintEVMV1Log(
      address: decode.getField(1),
      topics: decode.getFields<String>(2),
      data: decode.getField(3),
      blockNumber: decode.getField(4),
      transactionHash: decode.getField(5),
      transactionIndex: decode.getField(6),
      blockHash: decode.getField(7),
      logIndex: decode.getField(8),
      removed: decode.getField(9),
    );
  }

  @override
  List<int> get fieldIds => [1, 2, 3, 4, 5, 6, 7, 8, 9];

  @override
  Map<String, dynamic> toJson() {
    return {
      "address": address,
      "topics": topics,
      "data": BytesUtils.toHexString(data),
      "block_number": blockNumber,
      "tx_hash": transactionHash,
      "tx_index": transactionIndex,
      "block_hash": blockHash,
      "index": logIndex,
      "removed": removed,
    };
  }

  @override
  TypeUrl get typeUrl => EvmosErc20V1Types.log;

  @override
  List get values => [
    address,
    topics,
    data,
    blockNumber,
    transactionHash,
    transactionIndex,
    blockHash,
    logIndex,
    removed,
  ];
}
